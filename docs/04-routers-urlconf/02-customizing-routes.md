# Customizing Routes

## Problem

You need to customize the URL patterns generated by DRF routers to better match your API design or to add custom route formats that aren't provided by the default routers.

## Solution

Create custom router classes by subclassing `SimpleRouter` or `DefaultRouter` and overriding the `routes` attribute to define your own URL patterns.

## Code

### 1. Understanding Router Route Definition

First, let's understand how routes are defined in DRF routers:

```python
# Example from DRF's SimpleRouter (simplified)
from rest_framework.routers import Route, DynamicRoute

routes = [
    # List route
    Route(
        url=r'^{prefix}/$',
        mapping={'get': 'list', 'post': 'create'},
        name='{basename}-list',
        detail=False,
        initkwargs={'suffix': 'List'}
    ),
    # Detail route
    Route(
        url=r'^{prefix}/{lookup}/$',
        mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
        name='{basename}-detail',
        detail=True,
        initkwargs={'suffix': 'Instance'}
    ),
    # Custom actions
    DynamicRoute(
        url=r'^{prefix}/{lookup}/{url_path}/$',
        name='{basename}-{url_name}',
        detail=True,
        initkwargs={}
    ),
    DynamicRoute(
        url=r'^{prefix}/{url_path}/$',
        name='{basename}-{url_name}',
        detail=False,
        initkwargs={}
    )
]
```

Each `Route` object defines:
- `url`: URL pattern with placeholders
- `mapping`: Maps HTTP methods to viewset actions
- `name`: URL name pattern
- `detail`: Whether this is a detail or list view
- `initkwargs`: Additional arguments for the view

### 2. Basic Custom Router

Here's a simple custom router that changes the URL patterns:

```python
# routers.py
from rest_framework.routers import SimpleRouter, Route

class CustomRouter(SimpleRouter):
    """
    A router that uses kebab-case URLs instead of the default.
    """
    routes = [
        Route(
            # Using kebab-case for URLs
            url=r'^{prefix}/$',
            mapping={'get': 'list', 'post': 'create'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            # Using kebab-case for URLs
            url=r'^{prefix}/{lookup}/$',
            mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Instance'}
        ),
    ]
```

Using the custom router:

```python
# urls.py
from django.urls import path, include
from .routers import CustomRouter
from .views import BookViewSet

router = CustomRouter()
router.register(r'books', BookViewSet)

urlpatterns = [
    path('api/', include(router.urls)),
]
```

### 3. Adding Custom HTTP Method Mapping

You can customize the mapping of HTTP methods to viewset actions:

```python
# routers.py
from rest_framework.routers import SimpleRouter, Route

class ReadOnlyRouter(SimpleRouter):
    """
    A router that only allows GET requests.
    """
    routes = [
        Route(
            url=r'^{prefix}/$',
            mapping={'get': 'list'},  # Only GET allowed
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            url=r'^{prefix}/{lookup}/$',
            mapping={'get': 'retrieve'},  # Only GET allowed
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Instance'}
        ),
    ]
```

### 4. Changing URL Patterns

You can change the URL patterns to match your API design:

```python
# routers.py
from rest_framework.routers import SimpleRouter, Route, DynamicRoute

class ApiV1Router(SimpleRouter):
    """
    A router that prefixes all URLs with 'v1'.
    """
    routes = [
        Route(
            url=r'^v1/{prefix}/$',
            mapping={'get': 'list', 'post': 'create'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            url=r'^v1/{prefix}/{lookup}/$',
            mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Instance'}
        ),
        # Custom actions
        DynamicRoute(
            url=r'^v1/{prefix}/{lookup}/{url_path}/$',
            name='{basename}-{url_name}',
            detail=True,
            initkwargs={}
        ),
        DynamicRoute(
            url=r'^v1/{prefix}/{url_path}/$',
            name='{basename}-{url_name}',
            detail=False,
            initkwargs={}
        ),
    ]
```

### 5. Custom Lookup Value

You can change the lookup pattern to use slugs instead of numeric IDs:

```python
# routers.py
from rest_framework.routers import SimpleRouter, Route

class SlugRouter(SimpleRouter):
    """
    A router that uses slugs for lookups instead of primary keys.
    """
    routes = [
        Route(
            url=r'^{prefix}/$',
            mapping={'get': 'list', 'post': 'create'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            url=r'^{prefix}/{lookup}/$',
            mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Instance'}
        ),
    ]
    
    def get_lookup_regex(self, viewset, lookup_prefix=''):
        """
        Use slug lookups instead of numeric IDs.
        """
        lookup_field = getattr(viewset, 'lookup_field', 'slug')
        lookup_url_kwarg = getattr(viewset, 'lookup_url_kwarg', None) or lookup_field
        
        if lookup_prefix and self.trailing_slash:
            return f'(?P<{lookup_prefix}_{lookup_url_kwarg}>[^/.]+)/'
        
        return f'(?P<{lookup_url_kwarg}>[^/.]+)'
```

Using the slug router with a ViewSet:

```python
# views.py
from rest_framework import viewsets
from .models import Book
from .serializers import BookSerializer

class BookViewSet(viewsets.ModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    lookup_field = 'slug'  # Use slug instead of pk
```

### 6. Adding Extra Routes

You can add custom routes to your router:

```python
# routers.py
from rest_framework.routers import DefaultRouter, Route

class SearchableRouter(DefaultRouter):
    """
    A router that adds a search endpoint.
    """
    routes = DefaultRouter.routes + [
        # Add a custom search route
        Route(
            url=r'^{prefix}/search/$',
            mapping={'get': 'search'},
            name='{basename}-search',
            detail=False,
            initkwargs={'suffix': 'Search'}
        ),
    ]
```

With a corresponding ViewSet:

```python
# views.py
from rest_framework import viewsets
from rest_framework.response import Response
from .models import Book
from .serializers import BookSerializer

class BookViewSet(viewsets.ModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    
    def search(self, request):
        """
        Custom search action for the search route.
        """
        query = request.query_params.get('q', '')
        books = self.queryset.filter(title__icontains=query)
        serializer = self.get_serializer(books, many=True)
        return Response(serializer.data)
```

### 7. Nested Resource Router

You can create a router for nested resources:

```python
# routers.py
from rest_framework.routers import SimpleRouter, Route

class NestedRouter(SimpleRouter):
    """
    A router for nested resources.
    """
    routes = [
        Route(
            url=r'^{prefix}/{parent_lookup}/{nested_prefix}/$',
            mapping={'get': 'list', 'post': 'create'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            url=r'^{prefix}/{parent_lookup}/{nested_prefix}/{lookup}/$',
            mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Instance'}
        ),
    ]
    
    def __init__(self, parent_prefix, parent_lookup, nested_prefix, *args, **kwargs):
        self.parent_prefix = parent_prefix
        self.parent_lookup = parent_lookup
        self.nested_prefix = nested_prefix
        super().__init__(*args, **kwargs)
    
    def get_urls(self):
        """
        Use the parent and nested prefixes in the URL patterns.
        """
        urls = super().get_urls()
        
        # Replace the placeholders in the URL patterns
        for route in self.routes:
            route.url = route.url.format(
                prefix=self.parent_prefix,
                parent_lookup=self.parent_lookup,
                nested_prefix=self.nested_prefix
            )
        
        return urls
```

Using the nested router:

```python
# urls.py
from django.urls import path, include
from .routers import NestedRouter
from .views import AuthorBookViewSet

router = NestedRouter(
    parent_prefix='authors',
    parent_lookup='author_id',
    nested_prefix='books'
)
router.register(r'', AuthorBookViewSet)

urlpatterns = [
    path('api/', include(router.urls)),
]
```

### 8. Format Suffix Patterns

You can add format suffix patterns to your router:

```python
# routers.py
from rest_framework.routers import SimpleRouter, Route

class FormatSuffixRouter(SimpleRouter):
    """
    A router that adds format suffix patterns to URLs.
    """
    routes = [
        Route(
            url=r'^{prefix}{trailing_slash}$',
            mapping={'get': 'list', 'post': 'create'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'List'}
        ),
        Route(
            url=r'^{prefix}/{lookup}{trailing_slash}$',
            mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Instance'}
        ),
    ]
    
    def __init__(self, *args, **kwargs):
        self.format_suffix_patterns = True
        super().__init__(*args, **kwargs)
    
    def get_urls(self):
        """
        Add format suffix patterns to the URLs.
        """
        urls = super().get_urls()
        
        # Add format suffix patterns
        if self.format_suffix_patterns:
            from rest_framework.urlpatterns import format_suffix_patterns
            urls = format_suffix_patterns(urls)
        
        return urls
```

### 9. Custom Default Routes

You can customize the default routes for all your ViewSets:

```python
# routers.py
from rest_framework.routers import DefaultRouter

class CustomDefaultRouter(DefaultRouter):
    """
    A router with custom default routes.
    """
    
    def get_default_basename(self, viewset):
        """
        Override the default basename to use a custom naming convention.
        """
        # Example: Use 'api-book' instead of 'book'
        return f'api-{super().get_default_basename(viewset)}'
    
    def get_method_map(self, viewset, method_map):
        """
        Override the method mapping to customize the action names.
        """
        # Example: Use 'fetch' instead of 'retrieve'
        if 'retrieve' in method_map:
            method_map['retrieve'] = 'fetch'
        
        return method_map
```

### 10. Complex Router Configuration

Here's a more complex router configuration that combines multiple customizations:

```python
# routers.py
from rest_framework.routers import DefaultRouter, Route, DynamicRoute

class ComplexRouter(DefaultRouter):
    """
    A router with multiple customizations.
    """
    # Custom routes
    routes = [
        # List route with custom suffix
        Route(
            url=r'^{prefix}/$',
            mapping={'get': 'list', 'post': 'create'},
            name='{basename}-list',
            detail=False,
            initkwargs={'suffix': 'Collection'}  # Custom suffix
        ),
        # Detail route with custom lookup
        Route(
            url=r'^{prefix}/{lookup}/$',
            mapping={'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'},
            name='{basename}-detail',
            detail=True,
            initkwargs={'suffix': 'Item'}  # Custom suffix
        ),
        # Custom route for bulk operations
        Route(
            url=r'^{prefix}/bulk/$',
            mapping={'post': 'bulk_create', 'put': 'bulk_update', 'delete': 'bulk_destroy'},
            name='{basename}-bulk',
            detail=False,
            initkwargs={'suffix': 'Bulk'}
        ),
        # Custom route for stats
        Route(
            url=r'^{prefix}/stats/$',
            mapping={'get': 'stats'},
            name='{basename}-stats',
            detail=False,
            initkwargs={'suffix': 'Stats'}
        ),
        # Standard dynamic routes for custom actions
        DynamicRoute(
            url=r'^{prefix}/{lookup}/{url_path}/$',
            name='{basename}-{url_name}',
            detail=True,
            initkwargs={}
        ),
        DynamicRoute(
            url=r'^{prefix}/{url_path}/$',
            name='{basename}-{url_name}',
            detail=False,
            initkwargs={}
        ),
    ]
    
    def get_lookup_regex(self, viewset, lookup_prefix=''):
        """
        Override to support both numeric IDs and slugs.
        """
        # Check if the viewset specifies a lookup_field
        lookup_field = getattr(viewset, 'lookup_field', 'pk')
        
        # Use a different regex based on the lookup_field
        if lookup_field == 'slug':
            return r'(?P<{lookup_url_kwarg}>[a-z0-9][-a-z0-9]*)'
        elif lookup_field == 'uuid':
            return r'(?P<{lookup_url_kwarg}>[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})'
        else:
            return r'(?P<{lookup_url_kwarg}>\d+)'
```

## Notes

1. **Router Components**:
   - `Route`: Defines a URL pattern for static routes
   - `DynamicRoute`: Defines a URL pattern for dynamic routes (actions)
   - `routes`: List of Route objects that define the router's URL patterns
   - `get_lookup_regex()`: Method to get the lookup regex for detail views
   - `get_urls()`: Method to generate the final URL patterns

2. **Customization Points**:
   - URL patterns (via `url` in Route)
   - HTTP method mapping (via `mapping` in Route)
   - URL name patterns (via `name` in Route)
   - View kwargs (via `initkwargs` in Route)
   - Lookup pattern (via `get_lookup_regex()`)

3. **Common Customizations**:
   - Changing URL patterns for consistent API design
   - Adding custom routes for specific functionality
   - Modifying lookup behavior for different resource identifiers
   - Adding format suffix patterns
   - Nested resource routing

4. **When to Use Custom Routers**:
   - When you need consistent URL patterns across your API
   - When you want to add custom routes to all ViewSets
   - When you need to change the default lookup behavior
   - When you're building an API with non-standard URL patterns

5. **Best Practices**:
   - Start with the built-in routers before customizing
   - Test your custom router with multiple ViewSets
   - Document your custom URL patterns for API consumers
   - Consider using established patterns like kebab-case for consistency

6. **Advanced Uses**:
   - Multiple routers for different API versions
   - Conditional route generation based on ViewSet attributes
   - Dynamic route registration based on discovered ViewSets
   - Support for multiple lookup fields or composite keys

7. **Testing Router URLs**:
   - Use `reverse()` to test URL generation
   - Ensure all routes are accessible as expected
   - Test with different ViewSet configurations
